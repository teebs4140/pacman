<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collision Detection - Pacman Example</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        
        canvas {
            border: 2px solid #fff;
            background: #000;
            display: block;
            margin: 20px auto;
        }
        
        .controls {
            margin: 20px;
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #FFFF00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background: #FFD700;
        }
        
        .info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px auto;
            max-width: 800px;
        }
        
        .info-panel {
            background: #222;
            padding: 15px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <h1>Collision Detection Examples</h1>
    
    <div class="controls">
        <button onclick="toggleCollisionType()">Toggle: <span id="collisionType">AABB</span></button>
        <button onclick="resetGame()">Reset Game</button>
        <button onclick="addPellet()">Add Pellet</button>
        <button onclick="toggleDebug()">Toggle Debug</button>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="info">
        <div class="info-panel">
            <h3>Stats</h3>
            <p>Pellets Collected: <span id="collected">0</span></p>
            <p>Collisions: <span id="collisions">0</span></p>
            <p>Grid Position: <span id="gridPos">0, 0</span></p>
        </div>
        <div class="info-panel">
            <h3>Controls</h3>
            <p>Arrow keys to move</p>
            <p>Collect white pellets</p>
            <p>Avoid red obstacles</p>
        </div>
        <div class="info-panel">
            <h3>Collision Types</h3>
            <p><strong>AABB:</strong> Box collision</p>
            <p><strong>Circle:</strong> Radius collision</p>
            <p><strong>Grid:</strong> Tile-based collision</p>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRID_SIZE = 20;
        const GRID_WIDTH = Math.floor(canvas.width / GRID_SIZE);
        const GRID_HEIGHT = Math.floor(canvas.height / GRID_SIZE);
        
        // Game state
        let collisionType = 'AABB'; // 'AABB', 'Circle', 'Grid'
        let showDebug = false;
        let collisionCount = 0;
        
        const player = {
            x: 100,
            y: 100,
            size: 15,
            speed: 150,
            vx: 0,
            vy: 0,
            color: '#FFFF00'
        };
        
        let pellets = [];
        let obstacles = [];
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);
        
        // Initialize game objects
        function initGame() {
            pellets = [];
            obstacles = [];
            collisionCount = 0;
            
            // Create pellets
            for (let i = 0; i < 50; i++) {
                pellets.push({
                    x: Math.random() * (canvas.width - 20) + 10,
                    y: Math.random() * (canvas.height - 20) + 10,
                    size: 5,
                    color: '#FFFFFF'
                });
            }
            
            // Create obstacles
            for (let i = 0; i < 10; i++) {
                obstacles.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20,
                    width: 30 + Math.random() * 50,
                    height: 30 + Math.random() * 50,
                    color: '#FF0000'
                });
            }
        }
        
        // AABB Collision Detection
        function aabbCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Circle Collision Detection  
        function circleCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle1.size + circle2.size;
        }
        
        // Grid-based Collision Detection
        function getGridPosition(x, y) {
            return {
                gridX: Math.floor(x / GRID_SIZE),
                gridY: Math.floor(y / GRID_SIZE)
            };
        }
        
        function gridCollision(obj1, obj2) {
            const grid1 = getGridPosition(obj1.x, obj1.y);
            const grid2 = getGridPosition(obj2.x, obj2.y);
            return grid1.gridX === grid2.gridX && grid1.gridY === grid2.gridY;
        }
        
        // Check collisions based on current type
        function checkCollision(obj1, obj2) {
            switch(collisionType) {
                case 'AABB':
                    return aabbCollision(
                        {x: obj1.x - obj1.size, y: obj1.y - obj1.size, width: obj1.size * 2, height: obj1.size * 2},
                        {x: obj2.x - obj2.size, y: obj2.y - obj2.size, width: obj2.size * 2, height: obj2.size * 2}
                    );
                case 'Circle':
                    return circleCollision(obj1, obj2);
                case 'Grid':
                    return gridCollision(obj1, obj2);
                default:
                    return false;
            }
        }
        
        function checkObstacleCollision(player, obstacle) {
            switch(collisionType) {
                case 'AABB':
                    return aabbCollision(
                        {x: player.x - player.size, y: player.y - player.size, width: player.size * 2, height: player.size * 2},
                        obstacle
                    );
                case 'Circle':
                    // Treat obstacle as circle with radius = average of width/height
                    const obstacleRadius = (obstacle.width + obstacle.height) / 4;
                    return circleCollision(
                        player,
                        {x: obstacle.x + obstacle.width/2, y: obstacle.y + obstacle.height/2, size: obstacleRadius}
                    );
                case 'Grid':
                    return gridCollision(
                        player,
                        {x: obstacle.x + obstacle.width/2, y: obstacle.y + obstacle.height/2, size: 0}
                    );
                default:
                    return false;
            }
        }
        
        // Update game logic
        function update(deltaTime) {
            // Handle input
            player.vx = 0;
            player.vy = 0;
            
            if (keys['ArrowUp']) player.vy = -player.speed;
            if (keys['ArrowDown']) player.vy = player.speed;
            if (keys['ArrowLeft']) player.vx = -player.speed;
            if (keys['ArrowRight']) player.vx = player.speed;
            
            // Store old position for collision response
            const oldX = player.x;
            const oldY = player.y;
            
            // Update position
            player.x += player.vx * deltaTime;
            player.y += player.vy * deltaTime;
            
            // Boundary collision
            if (player.x < player.size || player.x > canvas.width - player.size) {
                player.x = oldX;
            }
            if (player.y < player.size || player.y > canvas.height - player.size) {
                player.y = oldY;
            }
            
            // Check obstacle collisions
            for (let obstacle of obstacles) {
                if (checkObstacleCollision(player, obstacle)) {
                    player.x = oldX;
                    player.y = oldY;
                    collisionCount++;
                    break;
                }
            }
            
            // Check pellet collisions
            for (let i = pellets.length - 1; i >= 0; i--) {
                if (checkCollision(player, pellets[i])) {
                    pellets.splice(i, 1);
                }
            }
            
            // Update UI
            document.getElementById('collected').textContent = 50 - pellets.length;
            document.getElementById('collisions').textContent = collisionCount;
            const gridPos = getGridPosition(player.x, player.y);
            document.getElementById('gridPos').textContent = `${gridPos.gridX}, ${gridPos.gridY}`;
        }
        
        // Render game
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid if in grid mode or debug mode
            if (collisionType === 'Grid' || showDebug) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // Draw obstacles
            for (let obstacle of obstacles) {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Debug: show collision bounds
                if (showDebug) {
                    ctx.strokeStyle = '#FF8888';
                    ctx.lineWidth = 2;
                    if (collisionType === 'Circle') {
                        const radius = (obstacle.width + obstacle.height) / 4;
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, radius, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else {
                        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    }
                }
            }
            
            // Draw pellets
            for (let pellet of pellets) {
                ctx.fillStyle = pellet.color;
                ctx.beginPath();
                ctx.arc(pellet.x, pellet.y, pellet.size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Debug: show collision bounds
                if (showDebug) {
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.lineWidth = 1;
                    if (collisionType === 'AABB') {
                        ctx.strokeRect(pellet.x - pellet.size, pellet.y - pellet.size, pellet.size * 2, pellet.size * 2);
                    } else {
                        ctx.beginPath();
                        ctx.arc(pellet.x, pellet.y, pellet.size, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw player
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, 2 * Math.PI);
            ctx.fill();
            
            // Debug: show collision bounds
            if (showDebug) {
                ctx.strokeStyle = '#FFFF88';
                ctx.lineWidth = 2;
                if (collisionType === 'AABB') {
                    ctx.strokeRect(player.x - player.size, player.y - player.size, player.size * 2, player.size * 2);
                } else {
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
            
            // Show current grid cell for player
            if (collisionType === 'Grid' || showDebug) {
                const gridPos = getGridPosition(player.x, player.y);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(
                    gridPos.gridX * GRID_SIZE,
                    gridPos.gridY * GRID_SIZE,
                    GRID_SIZE,
                    GRID_SIZE
                );
            }
        }
        
        // Game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Control functions
        function toggleCollisionType() {
            const types = ['AABB', 'Circle', 'Grid'];
            const currentIndex = types.indexOf(collisionType);
            collisionType = types[(currentIndex + 1) % types.length];
            document.getElementById('collisionType').textContent = collisionType;
        }
        
        function resetGame() {
            player.x = 100;
            player.y = 100;
            initGame();
        }
        
        function addPellet() {
            pellets.push({
                x: Math.random() * (canvas.width - 20) + 10,
                y: Math.random() * (canvas.height - 20) + 10,
                size: 5,
                color: '#FFFFFF'
            });
        }
        
        function toggleDebug() {
            showDebug = !showDebug;
        }
        
        // Initialize and start game
        initGame();
        requestAnimationFrame(gameLoop);
        
        console.log('Collision detection example loaded');
        console.log('Available collision types:', ['AABB', 'Circle', 'Grid']);
    </script>
</body>
</html>